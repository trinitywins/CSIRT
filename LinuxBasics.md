# Battle Room Scalping 

### Linux Basics
1. The touch utility is commonly used to reset the modified and accessed times that are associated with a file. If you 'touch a file that is already in place, the times that are associated with that file will get reset to the date and time at the time touch was run. Touch can also be used to se the date and time on a file to any value you would like. This can be done using the -1 flag.

	- If you try to touch a file that doesn't exist, touch will create an entry in the file tables for that file. The created, modified and accessed times will all be in the time that touch was run. The file will have no contents but all of the meta data will be stored in the filesystem.
	
2. Your working directory is the directory that you are currently in. Some programs use the idea of changing your working directory. For example, the File Transfer Protocol (FTP) fuction that puts you into a different directory is CWD for change working directory. In the case of Linux, though, all you need to do is use cd, which is the command to change your directory.

	- One thing ot keep in mind is where you are within the filesyste. On Linux systems, everything starts at / and exists below that. In that sense, the filesystem sturcture is like a tree. You start at the root (/) and then follow all of the branches up (through the filesystem is generally shown as coming down from the root) until you get to the leaves, which would be the files. If you want to use a relative position, you don't need to start the path with /. As an example, if you wanted to change to the directory temp that is in your current directory, all you would need to do is cd temp. That will change you into the temp directory that is below where you are. If you want to use an absolute path, you could use something like /hom/user1/temp to indicate the specific version you want to get to.
	
3. The echo program will print out anything that you tell it to. Essentially, it echoes back to you anyhting you want. If you were to type echo 'something', you would get something printed back to the screen for you. Your shell is the program that interfaces with you. It also incluedes the ability to interact with it as though it were a programming language, which it essentially is. As a result, you could set and retrieve variables. If you typed myvar='foo', you would then beable to echo $myvar to get the contents of the variable myvar. The $ essentially dereferences the name of the variable into the contents. If you were just to type echo myvar, you would get myvar and not the contents of your variable.

4. Your working directory is the directory that you are currently in. You can use a command to tell you which directory you are currently in if you have forgotten. If you are in the bahit of moving around the file system a lot on the command line, it can be hard to remember where you are. It's generally possible to put your current directory as part of your prompt on the command line, to help you keep track of where you are. You would typically get the last element (the name of your current directory rather than the entire path).

5. There are times when you may have information that you want to store in a file, except that output fom commands goes to the screen/console. In Linux, there are three standart streams, standard out (stdout), standard in (stdin) and standard error (stderr). If you want to send oe of these somewhere else, you need to use a redirect operator like > or <. You can send the output of the commands ot a file using > filename, for instance.

6. In Linux and other Unix-like operating systems , there is a utility that was designed to concatenate inputs to create a single output. This program, cat, can be used to take multiple files as inputs and send the concatenated output to standard out (stdout), which is typically the screen or console you are working in.

7. The original Unix manual, such as it was, was created by those who wrote the operating syste. As part of creating the manual, they were able to put the manual pages -- digital copies of the printed page -- into the environment so users could look up information without having to get up from their terminal to go refer to the manual pages. In order to view a manual page, all a user would have to do was type man command in order to get the documentation for the command specified.

8. The operating system keeps track of all of the running processes. The command to look at the process table is ps, but by default, you would only see processes that belong to you. All of the other processes on the system wouldn't be displayed.

9. One advantage of Linux and Unix, which it was built to behave like, is that the different commands and utilities were built to be unipurpose and small. In order to do bigger and more interesting things, you changed them together. In order to do that, you pipe the output of one program to the input of another using the | operator. A common use of this is to | the output of the one program into grep to search for a particular pattern.

10. Creating a directory in Linux is very simple. You would use the mkdir command. One of the nice features about mkdir is that you can create an entire path with it using -p. If you wanted to creat temp/1/3/5 bug you didn't have either temp or 1, you could use mkdir -p and it owuld automatically create all the necessary parents to the file directory you want.

11. Every file or directory has an owner. It also has a group. These settings allow you to set permissions. With Linux files, there is the possibility of setting read/write/execute permissions for owner, group and world. Changing the owner of a file or directory would change the permissions on the file. The chown command will allow you to change the owner of a file if you have permissions to do so.

12. Creation fuctions typically have opposite fuctions to remove the thing that has been created. In this case, rather than making the directory, you are removing the directory. One thing about removing directories that is different from files -- you can only remove a directory that is empty, meaning it has no files or other directories in it. Related to the command to remove a directory is the command to remove files -- rm. 

13. Permissions on files and directories are stored as a set of bits. Each category (owner, gourp, world) will have three bits associated to indicate read, write and execute. If the bit is set to 1, the permission associated with that bit is on. The most significat bit is read, the middle is write and the final is execute. An example of permissions is 600. The value 6 is composed of a 4 and 2 with bit values, we start counting positions with 0 so 2^2 = 4 plus 2 ^1 - 2 plus 0 means we have read and write for the owner. If it were 660, it owuld read and write for owner and group. Had the execute bit been set, the value would have been 7.

14. In order ot make a copy of a file or directory, you need to use a copy utility. Unlike other operating systems, Unix was created on hardwar that didn't have very much memory and also had terminals that were challenging to type on. Pushing keys was hard. In order to be economical, many Unix commands, in particular those that go back to the beginning, are two letters. Typically when commands are shortened, vowels can be taken out and the meaning can be understood. The consonants are important. When you are copying you copy from source to destination, as you might eepect.

15. Unix-like systems using file systems that inherit from the Unix File System (UFS) hav ethe ability to create links to files and directories. A link is a way of having one place to store information rather than having copies but allowing a reference to the data in multiple locations wihtin the filesystem. The operating system supports hard and soft links. With a hard link, the reference count in the index node (inode) that maintains the information about the file contents (the data) gets incremented. Deleting a hard link won't delete the data but instead, decrement the reference count. When the reference count hits 0, the data blocks associated with the file get freed. With a soft link, there is just an alias to the filename/location rather than to the data itself. The filename/location will then provide a reference to the data.
